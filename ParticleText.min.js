const ParticleTextWorker = `(${function () { const t = { x: 0, y: 0 }; const e = { x: 0, y: 0 }; const s = ['x', 'y', 'vx', 'vy', 'bx', 'by']; let i = 1; let r; let a; let h = !1; let n; let o = 0; let l; const g = { get x () { return 0.5 * n?.width }, get y () { return 0.5 * n?.height } }; class c {constructor (t = 0, e = [], s = 'float') { this.count = t, this.props = e, this.spread = e.length, this.values = s === 'float' ? new Float32Array(t * e.length) : new Uint32Array(t * e.length), this.values.get = function (t = 0, e = 0) { return this.slice(t, t + e) } } get length () { return this.values.length }set (t = [], e = 0) { this.values.set(t, e) }setMap (t = {}, e = 0) { this.set(Object.values(t), e) }get (t = 0) { return this.values.get(t, this.spread) }getMap (t = 0) { return this.get(t).reduce((t, e, s) => (t[this.props[s]] = e, t), {}) }forEach (t) { let e = 0; for (;e < this.length; e += this.spread)t(this.get(e), e, this) }map (t) { let e = 0; for (;e < this.length; e += this.spread) this.set(t(this.get(e), e, this), e) }} const { atan2: u, cos: p, pow: d, sin: m, sqrt: v } = Math; const $ = (t, e, s, i) => v(d(s - t, 2) + d(i - e, 2)); const y = (t, e, s, i) => u(i - e, s - t); const w = (t, e, s) => (1 - s) * t + s * e; const f = (t, e = 200) => { let s; return (...i) => { s && clearTimeout(s), s = setTimeout(() => t(...i), e) } }; self.addEventListener('message', ({ data: u }) => { const v = f(x, 200); if (u.type) switch (u.type) { case 'mousemove':!(function e ({ x: s, y: i }) { t.x = s, t.y = i }({ x: u.x, y: u.y })); break; case 'mouseenter':h = !0; break; case 'mouseleave':h = !1; break; case 'resize':v(u) } else u.canvas && (n = Object.assign({ get pixelDensity () { return (4 - this.density) * 4 }, get fontStyle () { return `${this.fontSize}px ${this.fontFamily}` } }, u.config), a = u.canvas.getContext('2d'), r = new OffscreenCanvas(n.width, n.height).getContext('2d'), a.canvas.width = n.width, a.canvas.height = n.height, x(n), (function s () { o = requestAnimationFrame(s); try { h ? (i = w(i, n.repelThreshold, 0.1), e.x = w(e.x, t.x, n.mLerpAmt), e.y = w(e.y, t.y, n.mLerpAmt)) : (i = w(i, 1, 0.1), e.x = w(e.x, g.x, n.mLerpAmt), e.y = w(e.y, g.y, n.mLerpAmt)), b(), a.clearRect(0, 0, n.width, n.height), l.forEach(([t, s, a, h, o, g], c) => { let u, v; u = t, v = s, u < 0 || u >= n.width || v < 0 || v >= n.height || (r.fillStyle = n.fontColor, r.fillRect(t, s, 1, 1)), l.set((function t (s, r, a, h, o, l) { const g = $(s, r, e.x, e.y); const c = y(e.x, e.y, s, r); const u = d(i, 2) / g * (g / i); const v = o - s; const f = l - r; return a = w(a, v + p(c) * u, n.vLerpAmt), h = w(h, f + m(c) * u, n.vLerpAmt), s = w(s, s + a, n.pLerpAmt), r = w(r, r + h, n.pLerpAmt), [s, r, a, h] }(t, s, a, h, o, g)), c) }), a.save(), a.fillStyle = n.backgroundColor, a.fillRect(0, 0, n.width, n.height), n.glow && (a.filter = 'blur(8px) brightness(200%)', a.drawImage(r.canvas, 0, 0), a.filter = 'blur(0)', a.globalCompositeOperation = 'lighter'), a.drawImage(r.canvas, 0, 0), a.restore() } catch (c) { cancelAnimationFrame(o), console.error('Error in render:', c) } }())); function x ({ width: e, height: i }) { (function e ({ width: s, height: i }) { n.width = s, n.height = i, r.canvas.width = s, r.canvas.height = i, r.drawImage(a.canvas, 0, 0), a.canvas.width = s, a.canvas.height = i, a.drawImage(r.canvas, 0, 0), t.x = g.x, t.y = g.y })({ width: e, height: i }), b(), r.font = n.fontStyle, r.textAlign = n.textAlign, r.textBaseline = n.textBaseline, (function t () { n.message, r.save(), r.lineWidth = 0.5, r[`${n.drawType}Text`](n.message, g.x, g.y, n.width - 32), r.restore(); const e = new Uint32Array(r.getImageData(0, 0, n.width, n.height).data); const i = []; let a; let h; let o; let u; let p; let d; let m; for (a = 0; a < e.length; a += 4)e[a + 3] && !(a % n.pixelDensity) && (h = u = a / 4 % n.width, o = p = a / 4 / n.width | 0, d = 0, m = 0, i.push(h, o, d, m, u, p)); (l = new c(i.length / s.length, s)).set(i, 0) }()) } function b () { r.clearRect(0, 0, n.width, n.height) } }) }.toString()})()`; const clamp = (t, e, s) => Math.min(Math.max(t, e), s); class ParticleText extends HTMLElement {static observedAttributes = ['drawType', 'backgroundColor', 'fontColor', 'fontFamily', 'fontSize', 'textAlign', 'textBaseline', 'message', 'density', 'glow', 'pLerpAmt', 'vLerpAmt', 'mLerpAmt', 'repelThreshold']; constructor () { super(), this.shadow = this.attachShadow({ mode: 'open' }), this.shadow.innerHTML = '<style media="screen">:host {cursor: pointer;display: block;}</style><canvas><slot></slot></canvas>' }connectedCallback () { const t = new Blob([ParticleTextWorker], { type: 'text/javascript' }); this.worker = new Worker(window.URL.createObjectURL(t)), this.canvas = this.shadow.querySelector('canvas'), this.canvas.style.backgroundColor = this.backgroundColor, this.osCanvas = this.canvas.transferControlToOffscreen(), this.width = this.parentElement.clientWidth, this.height = this.parentElement.clientHeight, this.resizeObserver = new ResizeObserver(t => { for (const e of t)(e.contentRect.width !== this.width || e.contentRect.height !== this.height) && (this.width = e.contentRect.width, this.height = e.contentRect.height, this.worker.postMessage({ type: 'resize', width: this.width, height: this.height })) }).observe(this.parentElement), this.worker.postMessage({ canvas: this.osCanvas, config: { width: this.width, height: this.height, message: this.message, drawType: this.drawType, backgroundColor: this.backgroundColor, fontColor: this.fontColor, fontFamily: this.fontFamily, fontSize: this.fontSize, textAlign: this.textAlign, textBaseline: this.textBaseline, density: this.density, glow: this.glow, pLerpAmt: this.pLerpAmt, vLerpAmt: this.vLerpAmt, mLerpAmt: this.mLerpAmt, repelThreshold: this.repelThreshold } }, [this.osCanvas]); const e = ({ offsetX: t, offsetY: e }) => { this.worker.postMessage({ type: 'mousemove', x: t, y: e }) }; const s = () => { this.worker.postMessage({ type: 'mouseenter' }) }; const i = () => { this.worker.postMessage({ type: 'mouseleave' }) }; this.canvas.addEventListener('mousemove', e), this.canvas.addEventListener('mouseenter', s), this.canvas.addEventListener('mouseleave', i) } get drawType () { return this.attributes.drawType?.value || 'stroke' } get backgroundColor () { return this.attributes.backgroundColor?.value || 'rgb(5, 15, 20)' } get fontColor () { return this.attributes.fontColor?.value || 'rgb(60, 200, 255)' } get fontSize () { return +this.attributes.fontSize?.value || 40 } get fontFamily () { return this.attributes.fontFamily?.value || 'monospace' } get fontStyle () { return `${this.fontSize}px ${this.fontFamily}` } get textAlign () { return this.attributes.textAlign?.value || 'center' } get textBaseline () { return this.attributes.textBaseline?.value || 'middle' } get message () { const t = this.shadow.querySelector('slot'); return t.assignedNodes()?.[0]?.textContent || this.attributes.message?.value || 'NO MESSAGE' } get density () { return this.attributes.density ? clamp(0 | +this.attributes.density.value, 1, 4) : 3 } get glow () { return this.attributes.glow?.value !== 'false' } get pLerpAmt () { return this.attributes.pLerpAmt ? clamp(+this.attributes.pLerpAmt.value, 0.05, 1) : 0.25 } get vLerpAmt () { return this.attributes.vLerpAmt ? clamp(+this.attributes.vLerpAmt.value, 0.05, 1) : 0.1 } get mLerpAmt () { return this.attributes.mLerpAmt ? clamp(+this.attributes.mLerpAmt.value, 0.05, 1) : 0.5 } get repelThreshold () { return this.attributes.repelThreshold ? clamp(+this.attributes.repelThreshold.value, 20, 200) : 50 }}customElements.define('particle-text', ParticleText)
